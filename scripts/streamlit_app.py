import streamlit as st
import joblib
from datetime import datetime, timedelta
import pandas as pd
from collections import deque
from predict_helpers import get_historical_pm25, pm25_to_aqi, create_features_for_prediction

st.set_page_config(
    page_title="AQI Forecaster",
    page_icon="ðŸ’¨",
    layout="wide"
)

API_KEY = st.secrets.get("OWM_API_KEY")

if not API_KEY:
    st.error("OWM_API_KEY not found. Please add it to Streamlit secrets")
    st.stop()

st.title("ðŸ’¨ Santa Clara County AQI Forecaster")
st.markdown("A predictive model for daily Air Quality Index (AQI) using machine learning.")

# @st.cache_resource tells Streamlit to run this function only once, to avoid reloading the model every time.
@st.cache_resource
def load_model(model_path):
    try:
        model = joblib.load(model_path)
        return model
    except FileNotFoundError:
        return None

# @st.cache_data tells Streamlit to run this function only if the inputs change, to avoid re-fetching data.
@st.cache_data
def fetch_recent_data(lat, lon, api_key, n_days):
    print("Fetching recent data from API...")
    recent_aqi = []
    today = datetime.now()
    for i in range(n_days, 0, -1):
        date_to_fetch = today - timedelta(days=i)
        pm25_val = get_historical_pm25(lat, lon, date_to_fetch, api_key)
        aqi_val = pm25_to_aqi(pm25_val)
        if aqi_val is not None:
            recent_aqi.append(aqi_val)
        else:
            recent_aqi.append(50) if not recent_aqi else recent_aqi.append(recent_aqi[-1])
    return recent_aqi

# --- Sidebar for Settings ---
st.sidebar.header("Model Settings")
model_choice = st.sidebar.selectbox(
    "Choose a Prediction Model:",
    ('model_santa_clara_fire_aware.joblib', 'model_2020.joblib')
)

# --- Main Application Logic ---
# Load the selected model

model = load_model('./models/' + model_choice)

if model is None:
    st.error(f"Model file {model_choice} is missing.")
else:
    # Fetch data
    last_7_days_aqi = fetch_recent_data(37.4323, -121.8996, API_KEY, 7)

    # Perform recursive forecast
    current_window = deque(last_7_days_aqi, maxlen=7)
    future_predictions = []
    for _ in range(7):
        input_features = create_features_for_prediction(current_window, 'DAILY_AQI_VALUE', 7)
        predicted_aqi = model.predict(input_features)[0]
        future_predictions.append(predicted_aqi)
        current_window.append(predicted_aqi)

    # --- Display the Forecast ---
    st.header(f"7-Day Forecast using '{model_choice}'")
    st.info(f"Prediction based on the last 7 days of actual AQI: `{[int(v) for v in last_7_days_aqi]}`")

    # DataFrame for the forecast to make plotting easy
    start_date = datetime.now() + timedelta(days=1)
    forecast_dates = pd.date_range(start=start_date, periods=7)
    forecast_df = pd.DataFrame({
        'Date': forecast_dates,
        'Predicted AQI': future_predictions
    }).set_index('Date')

    # Display metrics and a chart
    cols = st.columns(7)
    for i, col in enumerate(cols):
        with col:
            st.metric(
                label=forecast_df.index[i].strftime('%A, %b %d'),
                value=f"{forecast_df['Predicted AQI'][i]:.0f}"
            )
    
    st.subheader("Forecast Chart")
    st.line_chart(forecast_df['Predicted AQI'])

    with st.expander("About This Model"):
            st.write("""
                This forecast is generated by a Random Forest Regressor model.
                - **model_2020.joblib:** Trained only on "normal" air quality days from Jan-July 2020. It is not aware of extreme wildfire events.
                - **model_fire_aware.joblib:** Trained on all available 2020 data, including the major wildfire season. This model is more robust and cautious.

                The forecast accuracy will decrease for days further in the future. This is a project for learning and demonstration purposes.
            """)
